// URL to your external JSON (remote source of banner + version info).
// Contributors: update this to point to your hosted JSON when developing.
var JSON_URL = 'https://raw.githubusercontent.com/apersongithub/Duolingo-Unlimited-Hearts/refs/heads/main/extension-version.json';

(function () {
    'use strict';

    // Unique element id used to ensure we don't insert duplicate banners.
    const newElementId = 'extension-banner';

    // A minimal hard-coded fallback banner. This is used if the remote JSON is unreachable
    // or invalid. Because this string is authored in this repository it does not require
    // the same sanitization guarantees as untrusted remote content — but we still pass it
    // through the sanitizer before inserting to be consistent.
    const FALLBACK_CONFIG = {
        "BANNER": `
    <div class='thPiC'><img class='_1xOxM'
    src='https://raw.githubusercontent.com/apersongithub/Duolingo-Unlimited-Hearts/refs/heads/main/extras/icon.svg'
    style='border-radius:100px'></div>
<div class='_3jiBp'>
  <h4 class='qyEhl'>Duolingo Max Extension</h4><span class='_3S2Xa'>Created by <a
      href='https://github.com/apersongithub' target='_blank' style='color:#07b3ec'>apersongithub</a></span>
</div>
<div class='_36kJA'>
  <div><a href='https://html-preview.github.io/?url=https://raw.githubusercontent.com/apersongithub/Duolingo-Unlimited-Hearts/refs/heads/main/extras/donations.html'
      target='_blank'><button class='_1ursp _2V6ug _2paU5 _3gQUj _7jW2t rdtAy'><span class='_9lHjd'
          style='color:#d7d62b'>💵 Donate</span></button></a></div>
</div>
  `
    };

    /**
     * addCustomElement(config, root = document)
     * - Inserts the banner markup into the page next to an existing reference element.
     * - Prevents duplicates by checking for newElementId.
     * - The function expects `config.BANNER` to already be sanitized HTML (string).
     *
     * Parameters:
     * - config: object with BANNER string
     * - root: optional root node to run queries on (useful for testing)
     */
    function addCustomElement(config, root = document) {
        if (document.getElementById(newElementId)) return;

        // Target element chosen to match the site's DOM layout where we want the banner.
        const refElement = root.querySelector('.ky51z._26JAQ.MGk8p');
        if (!refElement) return;

        const ul = document.createElement('ul');
        ul.className = 'Y6o36';

        const newLi = document.createElement('li');
        newLi.id = newElementId;
        newLi.className = '_17J_p';
        // BANNER is trusted after sanitization; we set innerHTML to render the markup.
        newLi.innerHTML = config.BANNER;

        ul.appendChild(newLi);
        refElement.parentNode.insertBefore(ul, refElement.nextSibling);

        console.log('Extension banner successfully added!');
    }

    /**
     * loadConfigAndInject()
     * - Fetches remote JSON (JSON_URL) and injects the sanitized BANNER into the UI,
     *   but only when the user is on /settings/super.
     * - Falls back to FALLBACK_CONFIG if fetch fails.
     * - Because remote content could contain malicious markup, we sanitize it using
     *   a conservative allow-list before inserting into the page.
     */
    async function loadConfigAndInject() {
        // Only inject the banner on the specific settings page to avoid unintended UI changes.
        if (!window.location.pathname.includes('/settings/super')) return;

        /**
         * sanitizeHTML(unsafeHTML)
         * - Simple allow-list sanitizer implemented using a template + tree walker.
         * - Pros: small, deterministic, easy to audit.
         * - Cons: not a full replacement for a dedicated sanitizer library in more complex apps.
         *
         * Rules:
         * - Remove script/iframe/object/embed/style/link/meta elements entirely.
         * - Permit only a small set of tags and attributes (no inline event handlers).
         * - Only allow href/src values that start with http(s):// (no javascript:, data:, or relative URIs).
         * - Remove style attributes containing obviously dangerous patterns.
         */
        function sanitizeHTML(unsafeHTML) {
            const template = document.createElement('template');
            template.innerHTML = unsafeHTML || '';

            // Conservative allow-list of tags we permit in the banner
            const ALLOWED_TAGS = new Set([
                'DIV', 'SECTION',
                'H1', 'H2', 'H3', 'H4', 'H5', 'H6',
                'P', 'SPAN', 'SMALL',
                'A', 'BUTTON',
                'UL', 'OL', 'LI',
                'STRONG', 'EM', 'B', 'I', 'U',
                'BR', 'HR',
                'IMG'
            ]);
            // Attributes that are safe enough for a simple banner UI
            const ALLOWED_ATTRS = new Set([
                'class', 'id',
                'href', 'src', 'target', 'rel',
                'style',
                'alt', 'title',
                'role',
                'aria-label', 'aria-hidden', 'aria-describedby', 'aria-expanded', 'aria-controls',
                'width', 'height',
                'tabindex'
            ]);

            // Remove known dangerous elements completely
            template.content.querySelectorAll('script, iframe, object, embed, style, link, meta').forEach(el => el.remove());

            const walker = document.createTreeWalker(template.content, NodeFilter.SHOW_ELEMENT);
            let node;
            while ((node = walker.nextNode())) {
                // If the tag is not allowed, unwrap it but keep its children (safer than removing content).
                if (!ALLOWED_TAGS.has(node.tagName)) {
                    const parent = node.parentNode;
                    if (parent) parent.replaceChild(document.createDocumentFragment().append(...node.childNodes), node);
                    continue;
                }

                // Scrub attributes on allowed tags
                [...node.attributes].forEach(attr => {
                    const name = attr.name.toLowerCase();
                    const value = attr.value.trim();

                    // Remove event handlers (onclick etc.) and any attribute not on the allow-list
                    if (name.startsWith('on') || !ALLOWED_ATTRS.has(name)) {
                        node.removeAttribute(attr.name);
                        return;
                    }

                    // For href/src only allow absolute http(s) links
                    if (name === 'href' || name === 'src') {
                        const lower = value.toLowerCase();
                        if (!/^https?:\/\//.test(lower)) {
                            node.removeAttribute(attr.name);
                            return;
                        }
                        // Extra guard against javascript: and data: URIs
                        if (lower.startsWith('javascript:') || lower.startsWith('data:')) {
                            node.removeAttribute(attr.name);
                            return;
                        }
                    }

                    // Very small sanitization for style attribute to avoid obvious injection vectors.
                    if (name === 'style') {
                        if (/expression|javascript:|url\s*\(\s*javascript:/i.test(value)) {
                            node.removeAttribute(attr.name);
                        }
                    }
                });
            }

            // Return sanitized HTML string ready to insert via innerHTML
            return template.innerHTML;
        }

        try {
            const response = await fetch(JSON_URL, { cache: 'no-store' });
            if (!response.ok) throw new Error('Failed to fetch JSON');
            const remote = await response.json();

            // Only use the BANNER property from remote JSON (ignore scripts/other properties).
            // Sanitize it before injecting.
            const sanitized = sanitizeHTML(remote && remote.BANNER ? remote.BANNER : FALLBACK_CONFIG.BANNER);
            addCustomElement({ BANNER: sanitized });
        } catch (err) {
            // If remote fetch fails for any reason, fall back to the bundled banner.
            console.warn('Failed to load external JSON, using fallback:', err);
            const sanitizedFallback = sanitizeHTML(FALLBACK_CONFIG.BANNER);
            addCustomElement({ BANNER: sanitizedFallback });
        }
    }

    /**
     * removeManageSubscriptionSection(root = document)
     * - Removes the specific "Manage subscription" section from the page if present.
     * - This is a UI tweak: we search for section nodes with a specific class and exact heading text.
     * - The method is idempotent and safe to call repeatedly.
     */
    function removeManageSubscriptionSection(root = document) {
        const sections = root.querySelectorAll('section._3f-te');
        for (const section of sections) {
            const h2 = section.querySelector('h2._203-l');
            if (h2 && h2.textContent.trim() === 'Manage subscription') {
                section.remove();
                break;
            }
        }
    }

    // Observe DOM for dynamically added "Manage subscription" sections and remove them as soon as they appear.
    // Using a MutationObserver keeps behavior robust when the page is dynamically updated.
    const manageSubObserver = new MutationObserver(() => removeManageSubscriptionSection());
    manageSubObserver.observe(document.documentElement, { childList: true, subtree: true });

    // Run immediate cleanup on load as well
    removeManageSubscriptionSection();
    // Try to fetch the config and inject banner if appropriate
    loadConfigAndInject();

    // Observe DOM for dynamically added content and attempt to inject banner when relevant nodes appear.
    const observer = new MutationObserver(() => loadConfigAndInject());
    observer.observe(document.documentElement, { childList: true, subtree: true });
})();

window.addEventListener('load', () => {
    // Default metadata shown to users if the remote JSON doesn't provide it
    let EXTENSION_NAME = "Duolingo Max Extension";
    let EXTENSION_URL = "https://github.com/apersongithub/Duolingo-Unlimited-Hearts/";

    // Current extension version from the manifest. This is used to compare with remote version.
    let CURRENT_VERSION = chrome.runtime.getManifest().version; // fallback

    // Defaults for options stored in the extension's options page.
    // Contributors: when changing default behavior, update options UI accordingly.
    const DEFAULT_SETTINGS = {
        enableNotifications: true,
        major: { weeks: 0, days: 3, hours: 0, minutes: 0 },
        minor: { weeks: 1, days: 0, hours: 0, minutes: 0 }
    };

    /**
     * getIgnoreMs(duration)
     * - Converts an object with weeks/days/hours/minutes into milliseconds.
     * - Used to compute "ignore until" timestamps stored in localStorage.
     */
    function getIgnoreMs(duration) {
        return (
            ((duration.weeks * 7 * 24 * 60 * 60) +
                (duration.days * 24 * 60 * 60) +
                (duration.hours * 60 * 60) +
                (duration.minutes * 60)) * 1000
        );
    }

    /**
     * getSettings()
     * - Loads user settings from chrome.storage.sync (if available).
     * - Returns a Promise that resolves to an object with the effective settings.
     * - Keeps behavior tolerant to environments where chrome.storage is unavailable (e.g. tests).
     */
    const getSettings = () => new Promise(resolve => {
        try {
            if (chrome && chrome.storage && chrome.storage.sync) {
                chrome.storage.sync.get('settings', data => {
                    resolve((data && data.settings) || DEFAULT_SETTINGS);
                });
            } else {
                resolve(DEFAULT_SETTINGS);
            }
        } catch (_) {
            resolve(DEFAULT_SETTINGS);
        }
    });

    // After loading settings, check remote version and prompt user if an update is available.
    getSettings().then(settings => {
        // Respect user toggle for update notifications
        if (!settings.enableNotifications) return;

        // Keys used to store "ignore until" timestamps for major and minor update prompts.
        const ignoreKeyMajor = 'duo_extension_update_ignore_until_major';
        const ignoreKeyMinor = 'duo_extension_update_ignore_until_minor';
        const ignoreUntilMajor = localStorage.getItem(ignoreKeyMajor);
        const ignoreUntilMinor = localStorage.getItem(ignoreKeyMinor);
        const now = Date.now();

        // Fetch latest version info from the remote JSON and compare semver parts
        fetch(JSON_URL)
            .then(response => response.json())
            .then(data => {
                const latestVersion = data.version;
                const releaseDate = data.releaseDate; // ISO-ish string like "2025-08-28"
                const releaseNotes = data.releaseNotes || "";
                EXTENSION_NAME = data.EXTENSION_NAME || EXTENSION_NAME;
                EXTENSION_URL = data.EXTENSION_URL || EXTENSION_URL;

                // Parse semantic version parts into numbers for numeric comparison
                const currentParts = CURRENT_VERSION.split('.').map(Number);
                const latestParts = latestVersion.split('.').map(Number);

                // Calculate days since release (for user-facing messaging)
                const releaseDateObj = new Date(releaseDate);
                const diffTime = Math.abs(now - releaseDateObj);
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

                // compareVersions(a, b)
                // - Returns -1 if a < b, 0 if equal, 1 if a > b.
                // - Works when arrays have different lengths (missing parts treated as 0).
                function compareVersions(a, b) {
                    for (let i = 0; i < Math.max(a.length, b.length); i++) {
                        const numA = a[i] || 0;
                        const numB = b[i] || 0;
                        if (numA < numB) return -1;
                        if (numA > numB) return 1;
                    }
                    return 0;
                }

                const cmp = compareVersions(currentParts, latestParts);

                // formatDuration(d) -> human friendly "1 week, 2 days and 3 hours"
                const formatDuration = (d) => {
                    let minutes = Math.max(0, Number(d.minutes) || 0);
                    let hours = Math.max(0, Number(d.hours) || 0);
                    let days = Math.max(0, Number(d.days) || 0);
                    let weeks = Math.max(0, Number(d.weeks) || 0);

                    // Normalize smaller units into larger ones for nicer display
                    hours += Math.floor(minutes / 60);
                    minutes %= 60;

                    days += Math.floor(hours / 24);
                    hours %= 24;

                    weeks += Math.floor(days / 7);
                    days %= 7;

                    const parts = [];
                    if (weeks) parts.push(`${weeks} ${weeks === 1 ? 'week' : 'weeks'}`);
                    if (days) parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
                    if (hours) parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
                    if (minutes) parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);

                    if (parts.length === 0) return 'the configured period';
                    if (parts.length === 1) return parts[0];
                    return `${parts.slice(0, -1).join(', ')} and ${parts[parts.length - 1]}`;
                };

                // If remote version is newer, show either a major or minor update prompt.
                if (cmp < 0) {
                    // Major update when major version is greater (x -> y where y > x)
                    if (currentParts[0] < latestParts[0]) {
                        // Respect "ignore until" for major prompts
                        if (!ignoreUntilMajor || now > parseInt(ignoreUntilMajor, 10)) {
                            const ignoreMsMajor = getIgnoreMs(settings.major);
                            // For older current versions show a shorter/helpful note only on >=3.1
                            const showNote = (
                                currentParts[0] > 3 ||
                                (currentParts[0] === 3 && currentParts[1] >= 1)
                            );
                            const note = showNote ? "\n\n Note: You can disable these notifications in the options page." : "";
                            // Using confirm() for a blocking but simple UX. OK -> go to update URL; Cancel -> ignore for configured period.
                            if (confirm(`❗It's been ${diffDays} day(s) since a major update was released for ${EXTENSION_NAME}❗\n\n ⚠️ Please update for continued support ⚠️ \n\n Press OK to go to update page, or Cancel to ignore for ${formatDuration(settings.major)}.${note}`)) {
                                window.location.href = EXTENSION_URL;
                            } else {
                                localStorage.setItem(ignoreKeyMajor, (now + ignoreMsMajor).toString());
                            }
                        }
                    }
                    // Minor update (same major, newer minor)
                    else if (
                        (currentParts[0] === latestParts[0]) &&
                        (currentParts[1] < latestParts[1])
                    ) {
                        if (!ignoreUntilMinor || now > parseInt(ignoreUntilMinor, 10)) {
                            const ignoreMsMinor = getIgnoreMs(settings.minor);
                            const showNote = (
                                currentParts[0] > 3 ||
                                (currentParts[0] === 3 && currentParts[1] >= 1)
                            );
                            const note = showNote ? "\n\n Note: You can disable these notifications in the options page." : "";
                            if (confirm(`ℹ️ A minor update (${latestVersion}) is available for ${EXTENSION_NAME}. \n\n Release notes: \n${releaseNotes} \n\n Press OK to go to update page, or Cancel to ignore for ${formatDuration(settings.minor)}.${note}`)) {
                                window.location.href = EXTENSION_URL;
                            } else {
                                localStorage.setItem(ignoreKeyMinor, (now + ignoreMsMinor).toString());
                            }
                        }
                    }
                } else if (cmp > 0) {
                    // Current version is newer than the published latest -> likely a local/beta build.
                    alert(`🔨 You are using a beta version of ${EXTENSION_NAME}. Expect bugs and instability. Please report any issues on GitHub. \n\n IF YOU ARE NOT USING A BETA, IT IS A CACHE ISSUE. IGNORE THIS MESSAGE AND IT WILL GO AWAY WITHIN A FEW MINUTES`);
                }
                // cmp === 0 -> versions equal, do nothing.
            })
            .catch(() => {
                // Fail silently if unable to fetch version (non-blocking).
            });
    });
});
